1. int gettimeofday(struct timeval *tv, struct timezone *tz); --> the time returned by this function is measured in seconds since
   the Epoch, midnight on Jan 1 1970, if you just want to know the time, you can pass the null for second argument.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
2. one handy macro --> #define GET_ELAPSED_TIME(tv1,tv2) \
        ((double)(tv2.tv_sec - tv1.tv_sec) + 0.000001*(tv2.tv_usec - tv1.tv_usec))
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
3. to set up and use an interval timer, the system calls setitimer() and alarm() are also available.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
4. perf is the native linux profiling tool available on all distributions.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
5. ftrace is the native linux kernel tracer, it provides a built-in tracing mechanism which, coupled with some user space tools
 can make a tremendous amount of information available in near real time.
---> applicaion interface is provided by trace-cmd and kernelshark provides an attractive graphical interface.
--> trace.dat files generated on machine can be analyzed on another, even one of a totally different CPU architecture.
--> several tracers are availble as the part of ftrace and provide slight different features.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
6. gprof can be used for execution profiling, info will be gathered about the time spent in each function, the number of times
  	everything is called etc, not a line by line information per se.
   we can use gprof by compiling the code with -pg option, only compile those routines which we want to profile.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
7. to use gprof, -pg during compilation and then gprof binary(eg: a.out), we can use -b to make it less verbose.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
8. Intel offers vtune, which requires use of windows computer to run the user interface together with the target linux system.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
9. TAU provides complete performance analysis env for number of languages.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
10. some of the main utilities on your linux distribution are as below:
	
	ps --> Info about processes.
    
	top --> Dynamic view of running tasks and system.
    
	vmstat --> Info about memory paging, I/O, swapping etc.
    	vmstat --help or info vmstat can be useful.

    	free --> memory statistics.

	netstat --> network connections, routing and statistics etc.
	
	iostat --> Monitor I/O load.
 
	iotop --> Monitor I/O load per process.
	iotop --help or iotop -p pid 

	mpstat --> processor related statistics.
	mpstat --help or info mpstat can be useful
        
	sar --> collect, report, save system activity information.

Note: All of the above utilities gain their info from reading entries in the /proc filesystem which is a pseudo filesystem,we can directly examine entries there without using special programs once we become familiar with the formats of the various entries.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
11. valgrind is an integrated set of tools useful for profiling and debugging under Linux. the three main tools are memory error 
	detection , cache profiling and heap profiling.
	format to run is ---> valgrind --tool=toolname [option] exectable_name [arguments]
	toolname can be --> lackey,memcheck, corecheck, helgrind, massif, callgrind, cachegrind or none.
	Also compile the source code with -g flag.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
12. usage of valgrind with various tools inside it can slow down the program execution, also programs are instrumented and 
	run under a simulated CPU, valgrind --help is helpful and info valgrind is useful to see the various options.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
13. Valgrind will debug and profile shared libaries as well along with our program and thus output can be noisy, it is possible to 	selectively suppress the output from shared libraries.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
14.  memcheck --> detects use of uninitialized memory, accessing memory past the end of malloc region, accessing memory which has 
	already been freed.
     Also detects inappropriate use of stack areas, memory leaks(allocated buffers which are never freed or re-used) and also can 
    pinpoint other memory access related errors.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
15. cachegrind --> profiles the use of cache, simulates  L1,L2, D1 cpu caches and logs the no of cache hits and misses, memory refe	rences and instructions for each line of our program, it can slow down our programs upto 100 times.
	helper program callgrind is a wrapper which gives even more info, KDE application kcachegrind gives an advanced 
	graphical interface.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
16. helgrind --> Thread debugger which looks for multi-threaded race conditions.
		Identifies memory locations used by more than one thread without mutual exclusion primitives.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++17. massif --> heap profiler which produces a graph of heap usage over time.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
18. Address Sanitizer:
	it is a powerful tool developed by Google to detect the number of memory-related bugs such as "use-after-free" errors,
	memory leaks and out of range errors.
	it replaces the addrcheck tool in valgrind which is no longer available.
	it can be used by both gcc and clang compilers.
	we can use it in a following way:
		gcc -g -fsanitize=address -o test test.c
		./test
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
19. while linux distro should have full compiler support for address sanitizer sometimes it may not have libasan package installed.
	our program can fail to compile due to missing libasan package which can be easily installed with a command such as 
	sudo apt install libasan5
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	
 

