1. Processes are controlled by scheduling which is completetely preemptive and processes and can have different states, running and sleeping most common. Only the kernel has the right to preempt a process, they cannot do it to each other.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
2. init is usually the first process rn on a system and becomes the ancestor of all subsequent processes running onn the system,
except for those initiated directly from the kernel(which show up with [] around their name in ps listing).
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
3. Every process has pid, ppid and pgid. also it has code, date, variables, file descriptors and environment.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
4. A child process which terminates (either normally or abnormally) before its parent. which has not waited for it and examined
to check its exit code is known as Zombie(or defunct) process. Zombies have released almost all the resources and remain only to 
convey their exit status. one function of the init process is to check on its adopted children and let those who have terminated
die gracefully. hence it is sometimes known as zombie killer or child reaper.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
5. getpid, getppid, and getpgid() are some functions used.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
6. largest pid has been limited to 32768, we can alter this value by changing /proc/sys/kernel/pid_max, as processes are created
	eventually they will reach pid_max, at which point they will start again at pid = 300.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
7. threads(LWP) of a process shares the same pid but has a unique thread identifier.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
8. Per process usage or resource, limits are described by an array of rlimit structures.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
9. only the superuser can change rlim_cur to a value greater than rlim_max or change the rlim_max field.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
10. for x86 ,resource limits are defined in include/linux/resources.h.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
11. getrlimit or setrlimit can be used from the user space to get and set usage limits and report on current usage totals.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
12. ulimit -a can be used from the bash to see the values, pipe size(ulimit -p) cannot be changed and not the part of the RLIMIT
	set.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
13.  we can examine /proc/[pid]/limits to read the values set for a particular process ID.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
14. values for users , groups as well as system defaults can be set by editing the file /etc/security/limits.conf.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
15. It is important to note that the child processes inherits the rlim field of the parent task structure and thus begin with 
	the same limits.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
16.  getrusage() can also be used obtain detailed info about current usage totals, not all the fields are properly maintained in
	Linux , need to check man page to get that info.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
17. every process is also a member of a process group, processes can join or leave the process groups.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
18. A process group has a leader which pid = pgid , group continues even if the group leader terminates and end only when all
	of the members terminate.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
19. setpgid(), getpgid() , setgrp() and getpgrp() are used to manipulate process groups.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
20. setpgrp() is equivalent to setpgid(0,0) and getpgrp() is equivalent to getpgid(0).
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
21. proc filesystem is a peudo filesytem which exists only in memory, /proc is empty when the system is not running.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
22. Information in /proc is generated only when examined , it is not continously updated.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
23. Entries in /proc can be used to obtain system information when read. Writing to entries can set various system parameters.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
24. Name proc is short for process so /proc contains lot of info about processes running on the system, in addition to global info.
	for each process on the system there is subdir named with the process id.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
25. Some of these entries are very useful in /proc. map entry shows the memory mappings associated with the process, smaps shows 
	details on each segment, sched gives scheduling info, and the fd subdir gives info about all open file descriptors.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
26. man proc can give info about many of the entriesm both the process oriented and the global ones. one should be forewarned 
	that the exact contents of the proc filesystem tend to vary with the kernel version as new info is added and deprecated entries are removed, will need to explore myself.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
27. IPC techniques:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
28. Signals:
	signals can be used to send short messages between any two processes , regardless of their relationship, as long as privileges are appropriate, one of the oldest methods of ipc.
	Normally only a signal number is delivered, but with the siginfo interface, more info including the identity of the sending process can be supplied.
	Upon receiving a signal, a process suspends its normal operation. invokes a handling routine and then returns to where it was executing before handling the signal(or jumps to an alternative location) or exits.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
29. Pipes:
	Pipes created by the popen() and pipe() function, create a data flow between two processes which may or may not have an 
	ancestral relationship.
	Date flow proceeds only when both reader and a writer are present.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
30. Named Pipes(FIFOS):
	fifos create a data flow between two processes which may or may not have an ancestral relationship.
	A filesystem entry is setup and flow through the pipe is accomplished through normal I/O calls through the fifo.
	Data flow proceeds only when both a reader and a writer are present. there can be more than one reader and more than one
	writer.( FIFO stands for First In, First Out).
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
31. Unix Domain Sockets:
	Unix Domain Sockets create a data flow between two processes which may or may not have an ancestral relationship.
	A filesystem entry is setup and flow through the socket is accomplished by opening up socket descriptors and reading and 
	writing through them.
Unlike FIFOs communication is truly multiplex and bidirectional. there can be more than one reader and more than one writer.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
32. Internet Sockets:
	Internet sockets create a data flow between two processes which may be on different machines. there is no filesystem entry
	associated with them.
	Flow through the socket is accomplished by opening up socket descriptors and reading and writing through them, just as
	with UNIX Domain sockets.
	Once again communication is truly multiplex and bidirectional.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
33. system V IPC:
	System V IPC consist of three methods: shared memory, semaphores and message queues.
	Any processes which have access to the appropriate identifer can use these methods whether or not there is an ancestral 
	relationship.
	these methods are prone to leaks and have an interface which shows its age. they are used abundantly in legacy code, but
	can be avoided in new programs.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
34. POSIX IPC:
	Posix IPc consists of the same three methods as System V IPC , but has a vastly improved interface and communication.
	Shared resources show up as special filesystem entries.
	These methods are not prone to leaks and are a better choice than System V IPC.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
35. Multi-threading:
	Multi-threading applications have more than one thread of execution . they communicate among each other through shared
	resources such as memory and file descriptors.
	Careful coordination is required to preserve the integrity and sequencing of shared resources.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
36. Be careful while using format specifier in printing, for unsigned long it should %lu not %ld, it can corrupt the results.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
37. It might be possible that you might not change the process group id even if using functions like setpgid may be this is not 
	allowed.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
38. ps -eLF is handy command to see the threads as well, NLWP tells no of threads  and using LWP col, we can investigate thread as well by going to /core/pid/task/LWP_ID. 		
 
